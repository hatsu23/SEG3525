{"ast":null,"code":"import { LineFitter } from '../utils/lineFitter';\nimport { drawTrendline, fillBelowTrendline, setLineStyle } from '../utils/drawing';\nimport { addTrendlineLabel } from './label';\n\n/**\n * Adds a trendline (fitter) to the dataset on the chart and optionally labels it with trend value.\n * @param {Object} datasetMeta - Metadata about the dataset.\n * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.\n * @param {Object} dataset - The dataset configuration from the chart.\n * @param {Scale} xScale - The x-axis scale object.\n * @param {Scale} yScale - The y-axis scale object.\n */\nexport const addFitter = (datasetMeta, ctx, dataset, xScale, yScale) => {\n  const yAxisID = dataset.yAxisID || 'y'; // Default to 'y' if no yAxisID is specified\n  const yScaleToUse = datasetMeta.controller.chart.scales[yAxisID] || yScale;\n  const defaultColor = dataset.borderColor || 'rgba(169,169,169, .6)';\n  const {\n    colorMin = defaultColor,\n    colorMax = defaultColor,\n    width: lineWidth = dataset.borderWidth || 3,\n    lineStyle = 'solid',\n    fillColor = false\n    // trendoffset is now handled separately\n  } = dataset.trendlineLinear || {};\n  let trendoffset = (dataset.trendlineLinear || {}).trendoffset || 0;\n  const {\n    color = defaultColor,\n    text = 'Trendline',\n    display = true,\n    displayValue = true,\n    offset = 10,\n    percentage = false\n  } = dataset.trendlineLinear && dataset.trendlineLinear.label || {};\n  const {\n    family = \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n    size = 12\n  } = dataset.trendlineLinear && dataset.trendlineLinear.label && dataset.trendlineLinear.label.font || {};\n  const chartOptions = datasetMeta.controller.chart.options;\n  const parsingOptions = typeof chartOptions.parsing === 'object' ? chartOptions.parsing : undefined;\n  const xAxisKey = dataset.trendlineLinear?.xAxisKey || parsingOptions?.xAxisKey || 'x';\n  const yAxisKey = dataset.trendlineLinear?.yAxisKey || parsingOptions?.yAxisKey || 'y';\n  let fitter = new LineFitter();\n\n  // --- Data Point Collection and Validation for LineFitter ---\n\n  // Sanitize trendoffset: if its absolute value is too large, reset to 0.\n  // This prevents errors if offset is out of bounds of the dataset length.\n  if (Math.abs(trendoffset) >= dataset.data.length) trendoffset = 0;\n\n  // Determine the actual starting index for data processing if a positive trendoffset is applied.\n  // This skips initial data points and finds the first non-null data point thereafter.\n  // `effectiveFirstIndex` is used to determine the data type ('xy' or array) and to skip initial points for positive offset.\n  let effectiveFirstIndex = 0;\n  if (trendoffset > 0) {\n    // Start searching for a non-null point from the offset.\n    const firstNonNullAfterOffset = dataset.data.slice(trendoffset).findIndex(d => d !== undefined && d !== null);\n    if (firstNonNullAfterOffset !== -1) {\n      effectiveFirstIndex = trendoffset + firstNonNullAfterOffset;\n    } else {\n      // All points after the offset are null or undefined, so effectively no data for trendline.\n      effectiveFirstIndex = dataset.data.length;\n    }\n  } else {\n    // For zero or negative offset, the initial search for 'xy' type detection starts from the beginning of the dataset.\n    // The actual exclusion of points for negative offset (from the end) is handled per-point within the loop.\n    const firstNonNull = dataset.data.findIndex(d => d !== undefined && d !== null);\n    if (firstNonNull !== -1) {\n      effectiveFirstIndex = firstNonNull;\n    } else {\n      // All data in the dataset is null or undefined.\n      effectiveFirstIndex = dataset.data.length;\n    }\n  }\n\n  // Determine data structure type (object {x,y} or array of numbers) based on the first valid data point.\n  // This informs how `xAxisKey` and `yAxisKey` are used or if `index` is used for x-values.\n  let xy = effectiveFirstIndex < dataset.data.length && typeof dataset.data[effectiveFirstIndex] === 'object';\n\n  // Iterate over dataset to collect points for the LineFitter.\n  dataset.data.forEach((data, index) => {\n    // Skip any data point that is null or undefined directly. This is a general guard.\n    if (data == null) return;\n\n    // Apply trendoffset logic for including/excluding points:\n    // 1. Positive offset: Skip data points if their index is before the `effectiveFirstIndex`.\n    //    `effectiveFirstIndex` already accounts for the offset and initial nulls.\n    if (trendoffset > 0 && index < effectiveFirstIndex) return;\n    // 2. Negative offset: Skip data points if their index is at or after the calculated end point.\n    //    `dataset.data.length + trendoffset` marks the first index of the points to be excluded from the end.\n    //    For example, if length is 10 and offset is -2, points from index 8 onwards are skipped.\n    if (trendoffset < 0 && index >= dataset.data.length + trendoffset) return;\n\n    // Process data based on scale type and data structure.\n    if (['time', 'timeseries'].includes(xScale.options.type) && xy) {\n      // For time-based scales with object data, convert x to a numerical timestamp; ensure y is a valid number.\n      let x = data[xAxisKey] != null ? data[xAxisKey] : data.t; // `data.t` is a Chart.js internal fallback for time data.\n      const yValue = data[yAxisKey];\n\n      // Both x and y must be valid for the point to be included.\n      if (x != null && x !== undefined && yValue != null && !isNaN(yValue)) {\n        fitter.add(new Date(x).getTime(), yValue);\n      }\n      // If x or yValue is invalid, the point is skipped.\n    } else if (xy) {\n      // Data is identified as array of objects {x,y}.\n      const xVal = data[xAxisKey];\n      const yVal = data[yAxisKey];\n      const xIsValid = xVal != null && !isNaN(xVal);\n      const yIsValid = yVal != null && !isNaN(yVal);\n\n      // Both xVal and yVal must be valid numbers to include the point.\n      if (xIsValid && yIsValid) {\n        fitter.add(xVal, yVal);\n      }\n      // If either xVal or yVal is invalid, the point is skipped. No fallback to using index.\n    } else if (['time', 'timeseries'].includes(xScale.options.type) && !xy) {\n      // For time-based scales with array of numbers, get the x-value from the chart labels\n      const chartLabels = datasetMeta.controller.chart.data.labels;\n      if (chartLabels && chartLabels[index] && data != null && !isNaN(data)) {\n        const timeValue = new Date(chartLabels[index]).getTime();\n        if (!isNaN(timeValue)) {\n          fitter.add(timeValue, data);\n        }\n      }\n    } else {\n      // Data is an array of numbers (or other non-object types).\n      // The 'data' variable itself is the y-value, and 'index' is the x-value.\n      // We still need to check for null/NaN here because 'data' (the y-value) could be null/NaN\n      // even if the entry 'data' (the point/container) wasn't null in the initial check.\n      // This applies if dataset.data = [1, 2, null, 4].\n      if (data != null && !isNaN(data)) {\n        fitter.add(index, data);\n      }\n    }\n  });\n\n  // --- Trendline Coordinate Calculation ---\n  // Ensure there are enough points to form a trendline.\n  if (fitter.count < 2) {\n    return; // Not enough data points to calculate a trendline.\n  }\n\n  // These variables will hold the pixel coordinates for drawing the trendline.\n  let x1_px, y1_px, x2_px, y2_px;\n  const chartArea = datasetMeta.controller.chart.chartArea; // Defines the drawable area in pixels.\n\n  // Determine trendline start/end points based on the 'projection' option.\n  if (dataset.trendlineLinear.projection) {\n    const slope = fitter.slope();\n    const intercept = fitter.intercept();\n    let points = [];\n    if (Math.abs(slope) > 1e-6) {\n      const val_y_top = yScaleToUse.getValueForPixel(chartArea.top);\n      const x_at_top = (val_y_top - intercept) / slope;\n      points.push({\n        x: x_at_top,\n        y: val_y_top\n      });\n      const val_y_bottom = yScaleToUse.getValueForPixel(chartArea.bottom);\n      const x_at_bottom = (val_y_bottom - intercept) / slope;\n      points.push({\n        x: x_at_bottom,\n        y: val_y_bottom\n      });\n    } else {\n      points.push({\n        x: xScale.getValueForPixel(chartArea.left),\n        y: intercept\n      });\n      points.push({\n        x: xScale.getValueForPixel(chartArea.right),\n        y: intercept\n      });\n    }\n    const val_x_left = xScale.getValueForPixel(chartArea.left);\n    const y_at_left = fitter.f(val_x_left);\n    points.push({\n      x: val_x_left,\n      y: y_at_left\n    });\n    const val_x_right = xScale.getValueForPixel(chartArea.right);\n    const y_at_right = fitter.f(val_x_right);\n    points.push({\n      x: val_x_right,\n      y: y_at_right\n    });\n    const chartMinX = xScale.getValueForPixel(chartArea.left);\n    const chartMaxX = xScale.getValueForPixel(chartArea.right);\n    const yValsFromPixels = [yScaleToUse.getValueForPixel(chartArea.top), yScaleToUse.getValueForPixel(chartArea.bottom)];\n    const finiteYVals = yValsFromPixels.filter(y => isFinite(y));\n    // Ensure actualChartMinY and actualChartMaxY are correctly ordered for the filter\n    const actualChartMinY = finiteYVals.length > 0 ? Math.min(...finiteYVals) : -Infinity;\n    const actualChartMaxY = finiteYVals.length > 0 ? Math.max(...finiteYVals) : Infinity;\n    let validPoints = points.filter(p => isFinite(p.x) && isFinite(p.y) && p.x >= chartMinX && p.x <= chartMaxX && p.y >= actualChartMinY && p.y <= actualChartMaxY);\n    validPoints = validPoints.filter((point, index, self) => index === self.findIndex(t => Math.abs(t.x - point.x) < 1e-4 && Math.abs(t.y - point.y) < 1e-4));\n    if (validPoints.length >= 2) {\n      validPoints.sort((a, b) => a.x - b.x || a.y - b.y);\n      x1_px = xScale.getPixelForValue(validPoints[0].x);\n      y1_px = yScaleToUse.getPixelForValue(validPoints[0].y);\n      x2_px = xScale.getPixelForValue(validPoints[validPoints.length - 1].x);\n      y2_px = yScaleToUse.getPixelForValue(validPoints[validPoints.length - 1].y);\n    } else {\n      x1_px = NaN;\n      y1_px = NaN;\n      x2_px = NaN;\n      y2_px = NaN;\n    }\n  } else {\n    const y_at_minx = fitter.f(fitter.minx);\n    const y_at_maxx = fitter.f(fitter.maxx);\n    x1_px = xScale.getPixelForValue(fitter.minx);\n    y1_px = yScaleToUse.getPixelForValue(y_at_minx);\n    x2_px = xScale.getPixelForValue(fitter.maxx);\n    y2_px = yScaleToUse.getPixelForValue(y_at_maxx);\n  }\n\n  // --- Line Clipping and Drawing ---\n  let clippedCoords = null;\n  if (isFinite(x1_px) && isFinite(y1_px) && isFinite(x2_px) && isFinite(y2_px)) {\n    clippedCoords = liangBarskyClip(x1_px, y1_px, x2_px, y2_px, chartArea);\n  } else {}\n  if (clippedCoords) {\n    x1_px = clippedCoords.x1;\n    y1_px = clippedCoords.y1;\n    x2_px = clippedCoords.x2;\n    y2_px = clippedCoords.y2;\n    if (Math.abs(x1_px - x2_px) < 0.5 && Math.abs(y1_px - y2_px) < 0.5) {} else {\n      ctx.lineWidth = lineWidth;\n      setLineStyle(ctx, lineStyle);\n      drawTrendline({\n        ctx,\n        x1: x1_px,\n        y1: y1_px,\n        x2: x2_px,\n        y2: y2_px,\n        colorMin,\n        colorMax\n      });\n      if (fillColor) {\n        fillBelowTrendline(ctx, x1_px, y1_px, x2_px, y2_px, chartArea.bottom, fillColor);\n      }\n      const angle = Math.atan2(y2_px - y1_px, x2_px - x1_px);\n      const displaySlope = fitter.slope();\n      if (dataset.trendlineLinear.label && display !== false) {\n        const trendText = displayValue ? `${text} (Slope: ${percentage ? (displaySlope * 100).toFixed(2) + '%' : displaySlope.toFixed(2)})` : text;\n        addTrendlineLabel(ctx, trendText, x1_px, y1_px, x2_px, y2_px, angle, color, family, size, offset);\n      }\n    }\n  } else {}\n};\n\n/**\n * Clips a line segment to a rectangular clipping window using the Liang-Barsky algorithm.\n * This algorithm is efficient for 2D line clipping against an axis-aligned rectangle.\n * It determines the portion of the line segment (x1,y1)-(x2,y2) that is visible within\n * the rectangle defined by chartArea {left, right, top, bottom}.\n * @param {number} x1 - Pixel coordinate for the start of the line (x-axis).\n * @param {number} y1 - Pixel coordinate for the start of the line (y-axis).\n * @param {number} x2 - Pixel coordinate for the end of the line (x-axis).\n * @param {number} y2 - Pixel coordinate for the end of the line (y-axis).\n * @param {Object} chartArea - The chart area with { left, right, top, bottom } pixel boundaries.\n * @returns {Object|null} An object with { x1, y1, x2, y2 } of the clipped line, \n *                        or null if the line is entirely outside the window or clipped to effectively a point.\n */\nfunction liangBarskyClip(x1, y1, x2, y2, chartArea) {\n  let dx = x2 - x1; // Change in x\n  let dy = y2 - y1; // Change in y\n  let t0 = 0.0; // Parameter for the start of the clipped line segment (initially at x1, y1).\n  // Represents the proportion along the line from (x1,y1) to (x2,y2).\n  let t1 = 1.0; // Parameter for the end of the clipped line segment (initially at x2, y2).\n\n  // p and q arrays are used in the Liang-Barsky algorithm conditions.\n  // For each of the 4 clip edges (left, right, top, bottom):\n  // p[k] * t >= q[k]\n  // p values: -dx (left), dx (right), -dy (top), dy (bottom)\n  // q values: x1 - x_min (left), x_max - x1 (right), y1 - y_min (top), y_max - y1 (bottom)\n  // Note: Canvas y-coordinates increase downwards, so chartArea.top < chartArea.bottom.\n  const p = [-dx, dx, -dy, dy];\n  const q = [x1 - chartArea.left,\n  // q[0] for left edge check\n  chartArea.right - x1,\n  // q[1] for right edge check\n  y1 - chartArea.top,\n  // q[2] for top edge check\n  chartArea.bottom - y1 // q[3] for bottom edge check\n  ];\n  for (let i = 0; i < 4; i++) {\n    // Iterate through the 4 clip edges (left, right, top, bottom).\n    if (p[i] === 0) {\n      // Line is parallel to the i-th clipping edge.\n      if (q[i] < 0) {\n        // Line is outside this parallel edge (e.g., for left edge, x1 < chartArea.left).\n        return null; // Line is completely outside, so reject.\n      }\n      // If q[i] >= 0, line is inside or on the parallel edge, so this edge doesn't clip it. Continue.\n    } else {\n      const r = q[i] / p[i]; // Parameter t where the line intersects this edge's infinite line.\n      if (p[i] < 0) {\n        // Line is potentially entering the clip region with respect to this edge.\n        // (e.g., for left edge, -dx < 0 means line goes from left to right, dx > 0).\n        // We want the largest t0 among all entry points.\n        if (r > t1) return null; // Line enters after it has already exited from another edge.\n        t0 = Math.max(t0, r); // Update t0 to the latest entry point along the line.\n      } else {\n        // p[i] > 0\n        // Line is potentially exiting the clip region with respect to this edge.\n        // (e.g., for left edge, -dx > 0 means line goes from right to left, dx < 0).\n        // We want the smallest t1 among all exit points.\n        if (r < t0) return null; // Line exits before it has entered from another edge.\n        t1 = Math.min(t1, r); // Update t1 to the earliest exit point along the line.\n      }\n    }\n  }\n\n  // After checking all 4 edges:\n  // If t0 > t1, the line segment is completely outside the clipping window or is degenerate.\n  if (t0 > t1) return null;\n\n  // Calculate the new clipped coordinates using parameters t0 and t1.\n  // (x1_clipped, y1_clipped) = (x1, y1) + t0 * (dx, dy)\n  // (x2_clipped, y2_clipped) = (x1, y1) + t1 * (dx, dy)\n  const clippedX1 = x1 + t0 * dx;\n  const clippedY1 = y1 + t0 * dy;\n  const clippedX2 = x1 + t1 * dx;\n  const clippedY2 = y1 + t1 * dy;\n  return {\n    x1: clippedX1,\n    y1: clippedY1,\n    x2: clippedX2,\n    y2: clippedY2\n  };\n}\n// Removed adjustLineForOverflow function","map":{"version":3,"names":["LineFitter","drawTrendline","fillBelowTrendline","setLineStyle","addTrendlineLabel","addFitter","datasetMeta","ctx","dataset","xScale","yScale","yAxisID","yScaleToUse","controller","chart","scales","defaultColor","borderColor","colorMin","colorMax","width","lineWidth","borderWidth","lineStyle","fillColor","trendlineLinear","trendoffset","color","text","display","displayValue","offset","percentage","label","family","size","font","chartOptions","options","parsingOptions","parsing","undefined","xAxisKey","yAxisKey","fitter","Math","abs","data","length","effectiveFirstIndex","firstNonNullAfterOffset","slice","findIndex","d","firstNonNull","xy","forEach","index","includes","type","x","t","yValue","isNaN","add","Date","getTime","xVal","yVal","xIsValid","yIsValid","chartLabels","labels","timeValue","count","x1_px","y1_px","x2_px","y2_px","chartArea","projection","slope","intercept","points","val_y_top","getValueForPixel","top","x_at_top","push","y","val_y_bottom","bottom","x_at_bottom","left","right","val_x_left","y_at_left","f","val_x_right","y_at_right","chartMinX","chartMaxX","yValsFromPixels","finiteYVals","filter","isFinite","actualChartMinY","min","Infinity","actualChartMaxY","max","validPoints","p","point","self","sort","a","b","getPixelForValue","NaN","y_at_minx","minx","y_at_maxx","maxx","clippedCoords","liangBarskyClip","x1","y1","x2","y2","angle","atan2","displaySlope","trendText","toFixed","dx","dy","t0","t1","q","i","r","clippedX1","clippedY1","clippedX2","clippedY2"],"sources":["C:/Users/dioma/Downloads/react-playground-project/node_modules/chartjs-plugin-trendline/src/components/trendline.js"],"sourcesContent":["import { LineFitter } from '../utils/lineFitter';\nimport { drawTrendline, fillBelowTrendline, setLineStyle } from '../utils/drawing';\nimport { addTrendlineLabel } from './label';\n\n/**\n * Adds a trendline (fitter) to the dataset on the chart and optionally labels it with trend value.\n * @param {Object} datasetMeta - Metadata about the dataset.\n * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.\n * @param {Object} dataset - The dataset configuration from the chart.\n * @param {Scale} xScale - The x-axis scale object.\n * @param {Scale} yScale - The y-axis scale object.\n */\nexport const addFitter = (datasetMeta, ctx, dataset, xScale, yScale) => {\n    const yAxisID = dataset.yAxisID || 'y'; // Default to 'y' if no yAxisID is specified\n    const yScaleToUse = datasetMeta.controller.chart.scales[yAxisID] || yScale;\n\n    const defaultColor = dataset.borderColor || 'rgba(169,169,169, .6)';\n    const {\n        colorMin = defaultColor,\n        colorMax = defaultColor,\n        width: lineWidth = dataset.borderWidth || 3,\n        lineStyle = 'solid',\n        fillColor = false,\n        // trendoffset is now handled separately\n    } = dataset.trendlineLinear || {};\n    let trendoffset = (dataset.trendlineLinear || {}).trendoffset || 0;\n\n    const {\n        color = defaultColor,\n        text = 'Trendline',\n        display = true,\n        displayValue = true,\n        offset = 10,\n        percentage = false,\n    } = (dataset.trendlineLinear && dataset.trendlineLinear.label) || {};\n\n    const {\n        family = \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n        size = 12,\n    } = (dataset.trendlineLinear && dataset.trendlineLinear.label && dataset.trendlineLinear.label.font) || {};\n\n    const chartOptions = datasetMeta.controller.chart.options;\n    const parsingOptions =\n        typeof chartOptions.parsing === 'object'\n            ? chartOptions.parsing\n            : undefined;\n    const xAxisKey =\n        dataset.trendlineLinear?.xAxisKey || parsingOptions?.xAxisKey || 'x';\n    const yAxisKey =\n        dataset.trendlineLinear?.yAxisKey || parsingOptions?.yAxisKey || 'y';\n\n    let fitter = new LineFitter();\n    \n    // --- Data Point Collection and Validation for LineFitter ---\n\n    // Sanitize trendoffset: if its absolute value is too large, reset to 0.\n    // This prevents errors if offset is out of bounds of the dataset length.\n    if (Math.abs(trendoffset) >= dataset.data.length) trendoffset = 0;\n    \n    // Determine the actual starting index for data processing if a positive trendoffset is applied.\n    // This skips initial data points and finds the first non-null data point thereafter.\n    // `effectiveFirstIndex` is used to determine the data type ('xy' or array) and to skip initial points for positive offset.\n    let effectiveFirstIndex = 0;\n    if (trendoffset > 0) {\n        // Start searching for a non-null point from the offset.\n        const firstNonNullAfterOffset = dataset.data.slice(trendoffset).findIndex((d) => d !== undefined && d !== null);\n        if (firstNonNullAfterOffset !== -1) {\n            effectiveFirstIndex = trendoffset + firstNonNullAfterOffset;\n        } else {\n            // All points after the offset are null or undefined, so effectively no data for trendline.\n            effectiveFirstIndex = dataset.data.length; \n        }\n    } else {\n        // For zero or negative offset, the initial search for 'xy' type detection starts from the beginning of the dataset.\n        // The actual exclusion of points for negative offset (from the end) is handled per-point within the loop.\n        const firstNonNull = dataset.data.findIndex((d) => d !== undefined && d !== null);\n        if (firstNonNull !== -1) {\n            effectiveFirstIndex = firstNonNull;\n        } else {\n            // All data in the dataset is null or undefined.\n            effectiveFirstIndex = dataset.data.length; \n        }\n    }\n    \n    // Determine data structure type (object {x,y} or array of numbers) based on the first valid data point.\n    // This informs how `xAxisKey` and `yAxisKey` are used or if `index` is used for x-values.\n    let xy = effectiveFirstIndex < dataset.data.length && typeof dataset.data[effectiveFirstIndex] === 'object';\n\n    // Iterate over dataset to collect points for the LineFitter.\n    dataset.data.forEach((data, index) => {\n        // Skip any data point that is null or undefined directly. This is a general guard.\n        if (data == null) return; \n        \n        // Apply trendoffset logic for including/excluding points:\n        // 1. Positive offset: Skip data points if their index is before the `effectiveFirstIndex`.\n        //    `effectiveFirstIndex` already accounts for the offset and initial nulls.\n        if (trendoffset > 0 && index < effectiveFirstIndex) return;\n        // 2. Negative offset: Skip data points if their index is at or after the calculated end point.\n        //    `dataset.data.length + trendoffset` marks the first index of the points to be excluded from the end.\n        //    For example, if length is 10 and offset is -2, points from index 8 onwards are skipped.\n        if (trendoffset < 0 && index >= dataset.data.length + trendoffset) return;\n\n        // Process data based on scale type and data structure.\n        if (['time', 'timeseries'].includes(xScale.options.type) && xy) {\n            // For time-based scales with object data, convert x to a numerical timestamp; ensure y is a valid number.\n            let x = data[xAxisKey] != null ? data[xAxisKey] : data.t; // `data.t` is a Chart.js internal fallback for time data.\n            const yValue = data[yAxisKey];\n\n            // Both x and y must be valid for the point to be included.\n            if (x != null && x !== undefined && yValue != null && !isNaN(yValue)) {\n                fitter.add(new Date(x).getTime(), yValue);\n            }\n            // If x or yValue is invalid, the point is skipped.\n        } else if (xy) { // Data is identified as array of objects {x,y}.\n            const xVal = data[xAxisKey];\n            const yVal = data[yAxisKey];\n\n            const xIsValid = xVal != null && !isNaN(xVal);\n            const yIsValid = yVal != null && !isNaN(yVal);\n\n            // Both xVal and yVal must be valid numbers to include the point.\n            if (xIsValid && yIsValid) {\n                fitter.add(xVal, yVal);\n            }\n            // If either xVal or yVal is invalid, the point is skipped. No fallback to using index.\n        } else if (['time', 'timeseries'].includes(xScale.options.type) && !xy) {\n            // For time-based scales with array of numbers, get the x-value from the chart labels\n            const chartLabels = datasetMeta.controller.chart.data.labels;\n            if (chartLabels && chartLabels[index] && data != null && !isNaN(data)) {\n                const timeValue = new Date(chartLabels[index]).getTime();\n                if (!isNaN(timeValue)) {\n                    fitter.add(timeValue, data);\n                }\n            }\n        } else { \n            // Data is an array of numbers (or other non-object types).\n            // The 'data' variable itself is the y-value, and 'index' is the x-value.\n            // We still need to check for null/NaN here because 'data' (the y-value) could be null/NaN\n            // even if the entry 'data' (the point/container) wasn't null in the initial check.\n            // This applies if dataset.data = [1, 2, null, 4].\n            if (data != null && !isNaN(data)) {\n                 fitter.add(index, data);\n            }\n        }\n    });\n\n    // --- Trendline Coordinate Calculation ---\n    // Ensure there are enough points to form a trendline.\n    if (fitter.count < 2) {\n        return; // Not enough data points to calculate a trendline.\n    }\n\n    // These variables will hold the pixel coordinates for drawing the trendline.\n    let x1_px, y1_px, x2_px, y2_px; \n\n    const chartArea = datasetMeta.controller.chart.chartArea; // Defines the drawable area in pixels.\n\n    // Determine trendline start/end points based on the 'projection' option.\n    if (dataset.trendlineLinear.projection) {\n        const slope = fitter.slope();\n        const intercept = fitter.intercept();\n        let points = []; \n\n        if (Math.abs(slope) > 1e-6) { \n            const val_y_top = yScaleToUse.getValueForPixel(chartArea.top);\n            const x_at_top = (val_y_top - intercept) / slope; \n            points.push({ x: x_at_top, y: val_y_top });\n\n            const val_y_bottom = yScaleToUse.getValueForPixel(chartArea.bottom);\n            const x_at_bottom = (val_y_bottom - intercept) / slope; \n            points.push({ x: x_at_bottom, y: val_y_bottom });\n        } else { \n             points.push({ x: xScale.getValueForPixel(chartArea.left), y: intercept});\n             points.push({ x: xScale.getValueForPixel(chartArea.right), y: intercept});\n        }\n\n        const val_x_left = xScale.getValueForPixel(chartArea.left);\n        const y_at_left = fitter.f(val_x_left); \n        points.push({ x: val_x_left, y: y_at_left });\n\n        const val_x_right = xScale.getValueForPixel(chartArea.right);\n        const y_at_right = fitter.f(val_x_right); \n        points.push({ x: val_x_right, y: y_at_right });\n        \n        const chartMinX = xScale.getValueForPixel(chartArea.left); \n        const chartMaxX = xScale.getValueForPixel(chartArea.right); \n        \n        const yValsFromPixels = [yScaleToUse.getValueForPixel(chartArea.top), yScaleToUse.getValueForPixel(chartArea.bottom)];\n        const finiteYVals = yValsFromPixels.filter(y => isFinite(y));\n        // Ensure actualChartMinY and actualChartMaxY are correctly ordered for the filter\n        const actualChartMinY = finiteYVals.length > 0 ? Math.min(...finiteYVals) : -Infinity; \n        const actualChartMaxY = finiteYVals.length > 0 ? Math.max(...finiteYVals) : Infinity;\n        \n        let validPoints = points.filter(p => \n            isFinite(p.x) && isFinite(p.y) && \n            p.x >= chartMinX && p.x <= chartMaxX && p.y >= actualChartMinY && p.y <= actualChartMaxY\n        );\n        \n        validPoints = validPoints.filter((point, index, self) =>\n            index === self.findIndex((t) => (\n                Math.abs(t.x - point.x) < 1e-4 && Math.abs(t.y - point.y) < 1e-4 \n            ))\n        );\n        \n        if (validPoints.length >= 2) {\n            validPoints.sort((a,b) => a.x - b.x || a.y - b.y); \n\n            x1_px = xScale.getPixelForValue(validPoints[0].x);\n            y1_px = yScaleToUse.getPixelForValue(validPoints[0].y);\n            x2_px = xScale.getPixelForValue(validPoints[validPoints.length - 1].x);\n            y2_px = yScaleToUse.getPixelForValue(validPoints[validPoints.length - 1].y);\n        } else {\n            x1_px = NaN; y1_px = NaN; x2_px = NaN; y2_px = NaN;\n        }\n\n    } else {\n        const y_at_minx = fitter.f(fitter.minx); \n        const y_at_maxx = fitter.f(fitter.maxx); \n\n        x1_px = xScale.getPixelForValue(fitter.minx);\n        y1_px = yScaleToUse.getPixelForValue(y_at_minx);\n        x2_px = xScale.getPixelForValue(fitter.maxx);\n        y2_px = yScaleToUse.getPixelForValue(y_at_maxx);\n    }\n\n    // --- Line Clipping and Drawing ---\n    let clippedCoords = null;\n    if (isFinite(x1_px) && isFinite(y1_px) && isFinite(x2_px) && isFinite(y2_px)) {\n        clippedCoords = liangBarskyClip(x1_px, y1_px, x2_px, y2_px, chartArea);\n    } else {\n    }\n\n    if (clippedCoords) {\n        x1_px = clippedCoords.x1;\n        y1_px = clippedCoords.y1;\n        x2_px = clippedCoords.x2;\n        y2_px = clippedCoords.y2;\n\n        if (Math.abs(x1_px - x2_px) < 0.5 && Math.abs(y1_px - y2_px) < 0.5) { \n        } else {\n            ctx.lineWidth = lineWidth;\n            setLineStyle(ctx, lineStyle);\n            drawTrendline({ ctx, x1: x1_px, y1: y1_px, x2: x2_px, y2: y2_px, colorMin, colorMax });\n\n            if (fillColor) {\n                fillBelowTrendline(ctx, x1_px, y1_px, x2_px, y2_px, chartArea.bottom, fillColor);\n            }\n\n            const angle = Math.atan2(y2_px - y1_px, x2_px - x1_px);\n            const displaySlope = fitter.slope();\n\n            if (dataset.trendlineLinear.label && display !== false) {\n                const trendText = displayValue\n                    ? `${text} (Slope: ${\n                          percentage\n                              ? (displaySlope * 100).toFixed(2) + '%' \n                              : displaySlope.toFixed(2)\n                      })`\n                    : text;\n                addTrendlineLabel(\n                    ctx,\n                    trendText,\n                    x1_px, \n                    y1_px,\n                    x2_px,\n                    y2_px,\n                    angle,\n                    color,\n                    family,\n                    size,\n                    offset\n                );\n            }\n        }\n    } else {\n    }\n};\n\n/**\n * Clips a line segment to a rectangular clipping window using the Liang-Barsky algorithm.\n * This algorithm is efficient for 2D line clipping against an axis-aligned rectangle.\n * It determines the portion of the line segment (x1,y1)-(x2,y2) that is visible within\n * the rectangle defined by chartArea {left, right, top, bottom}.\n * @param {number} x1 - Pixel coordinate for the start of the line (x-axis).\n * @param {number} y1 - Pixel coordinate for the start of the line (y-axis).\n * @param {number} x2 - Pixel coordinate for the end of the line (x-axis).\n * @param {number} y2 - Pixel coordinate for the end of the line (y-axis).\n * @param {Object} chartArea - The chart area with { left, right, top, bottom } pixel boundaries.\n * @returns {Object|null} An object with { x1, y1, x2, y2 } of the clipped line, \n *                        or null if the line is entirely outside the window or clipped to effectively a point.\n */\nfunction liangBarskyClip(x1, y1, x2, y2, chartArea) {\n    let dx = x2 - x1; // Change in x\n    let dy = y2 - y1; // Change in y\n    let t0 = 0.0;     // Parameter for the start of the clipped line segment (initially at x1, y1).\n                      // Represents the proportion along the line from (x1,y1) to (x2,y2).\n    let t1 = 1.0;     // Parameter for the end of the clipped line segment (initially at x2, y2).\n\n    // p and q arrays are used in the Liang-Barsky algorithm conditions.\n    // For each of the 4 clip edges (left, right, top, bottom):\n    // p[k] * t >= q[k]\n    // p values: -dx (left), dx (right), -dy (top), dy (bottom)\n    // q values: x1 - x_min (left), x_max - x1 (right), y1 - y_min (top), y_max - y1 (bottom)\n    // Note: Canvas y-coordinates increase downwards, so chartArea.top < chartArea.bottom.\n    const p = [-dx, dx, -dy, dy];\n    const q = [\n        x1 - chartArea.left,    // q[0] for left edge check\n        chartArea.right - x1,   // q[1] for right edge check\n        y1 - chartArea.top,     // q[2] for top edge check\n        chartArea.bottom - y1,  // q[3] for bottom edge check\n    ];\n\n    for (let i = 0; i < 4; i++) { // Iterate through the 4 clip edges (left, right, top, bottom).\n        if (p[i] === 0) { // Line is parallel to the i-th clipping edge.\n            if (q[i] < 0) { // Line is outside this parallel edge (e.g., for left edge, x1 < chartArea.left).\n                return null; // Line is completely outside, so reject.\n            }\n            // If q[i] >= 0, line is inside or on the parallel edge, so this edge doesn't clip it. Continue.\n        } else {\n            const r = q[i] / p[i]; // Parameter t where the line intersects this edge's infinite line.\n            if (p[i] < 0) { \n                // Line is potentially entering the clip region with respect to this edge.\n                // (e.g., for left edge, -dx < 0 means line goes from left to right, dx > 0).\n                // We want the largest t0 among all entry points.\n                if (r > t1) return null; // Line enters after it has already exited from another edge.\n                t0 = Math.max(t0, r);    // Update t0 to the latest entry point along the line.\n            } else { // p[i] > 0\n                // Line is potentially exiting the clip region with respect to this edge.\n                // (e.g., for left edge, -dx > 0 means line goes from right to left, dx < 0).\n                // We want the smallest t1 among all exit points.\n                if (r < t0) return null; // Line exits before it has entered from another edge.\n                t1 = Math.min(t1, r);    // Update t1 to the earliest exit point along the line.\n            }\n        }\n    }\n\n    // After checking all 4 edges:\n    // If t0 > t1, the line segment is completely outside the clipping window or is degenerate.\n    if (t0 > t1) return null; \n\n    // Calculate the new clipped coordinates using parameters t0 and t1.\n    // (x1_clipped, y1_clipped) = (x1, y1) + t0 * (dx, dy)\n    // (x2_clipped, y2_clipped) = (x1, y1) + t1 * (dx, dy)\n    const clippedX1 = x1 + t0 * dx;\n    const clippedY1 = y1 + t0 * dy;\n    const clippedX2 = x1 + t1 * dx;\n    const clippedY2 = y1 + t1 * dy;\n\n    return { x1: clippedX1, y1: clippedY1, x2: clippedX2, y2: clippedY2 };\n}\n// Removed adjustLineForOverflow function"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}